import numpy as np
from gamestate import GameState
from gui import Gui
import random

"""
Notes:
    Only static methods -> don't create instances e.g. just call Board.func()
    To use:
        initBoard(*Bitboards, blue_turn) -> None   # new game
        generate_moves() -> [(source1, [dest1, dest2, ...]), ...] # generates all possible moves of the current player
        exec_move(source, dest) -> (blue_pawns, blue_knights, red_pawns, red_knights) # executes move of the current player
        takeback -> takeback last move
        isOver  -> checks if the game is over
        --> check isOver after initBoard and after exec_move

    In process (don't use yet):
        eval() -> int # evaluation of the current board
"""



class Board():
    @staticmethod
    def initBoard(red_pawns, red_knights,blue_pawns, blue_knights, blue_turn=True) -> None:
        """
        Sets up new game:
        Call like this: 
            Board.initBoard(*GameState.createBitBoardFrom(Gui.fenToMatrix(FEN_board),True),blue_turn:bool)

        Imports needed for that:
            from src.gamestate import GameState
            from src.gui import Gui
        """
        Board.blue_turn = blue_turn
        Board.blue_p = blue_pawns
        Board.blue_k = blue_knights
        Board.blue = blue_pawns | blue_knights
        Board.red_p = red_pawns
        Board.red_k = red_knights
        Board.red = red_pawns | red_knights
        Board.l_blue_p=[]
        Board.l_blue_k=[]
        Board.l_red_p=[]
        Board.l_red_k=[]
        for bit_board, figure_list in zip((Board.blue_p, Board.blue_k, Board.red_p, Board.red_k),(Board.l_blue_p,Board.l_blue_k,Board.l_red_p,Board.l_red_k)):
            for bit in range(64):
                if bit_board & (np.uint64(1 << bit)):
                    figure_list.append(np.uint64(1 << bit))

    @staticmethod
    def generate_moves() -> list:
        """
        Format of the returned list:
        [(source1, [dest1, dest2, ...]), (source2, [dest1, dest2, ...]), ...]
        """
        if Board.blue_turn:
            return Board.blue_generation()
        else:
            return Board.red_generation()
    
    @staticmethod
    def exec_move(source:np.uint64, dest:np.uint64) -> tuple:
        """
        switches player automatically after execution
        Args: source, dest
        Returns: (blue_p, blue_k, red_p, red_k) # all bitboards for transition table
        """
        if Board.blue_turn:
            if source & Board.blue_k:
                Board.blue_k_move_execution(source, dest)
            else:
                Board.blue_p_move_execution(source, dest)
        else:
            if source & Board.red_k:
                Board.red_k_move_execution(source, dest)
            else:
                Board.red_p_move_execution(source, dest)
        Board.blue_turn = not Board.blue_turn
        return Board.blue_p, Board.blue_k, Board.red_p, Board.red_k
         
    @staticmethod
    def takeback() -> None:
        """
        switches player automatically after execution
        
        """
        if Board.blue_turn:
            Board.red_takeback(*Board.stack.pop())
        else:
            Board.blue_takeback(*Board.stack.pop())
        Board.blue_turn = not Board.blue_turn
    
    @staticmethod
    def isOver() -> str:
        """
        Returns: "blue" or "red" if one of the players has won, "" if not
        """
        if Board.blue & Board.blue_on_ground_row:
            return "blue"
        elif Board.red & Board.red_on_ground_row:
            return "red"
        else:
            return ""
        
    ################### Class Variables #####################
        
    blue_on_ground_row = np.uint64(0b0111111000000000000000000000000000000000000000000000000000000000)
    red_on_ground_row = np.uint64(0b0000000000000000000000000000000000000000000000000000000001111110)

    # Turn
    blue_turn = True

    # Game Repr
    stack = []

    # Blue
    blue_p, blue_k = np.uint64(0b0111111001111110), np.uint64(0) 
    blue = blue_p | blue_k
    l_blue_k, l_blue_p = [],[]

    # Red pawns
    red_p, red_k = np.uint64(0b0111111001111110000000000000000000000000000000000000000000000000), np.uint64(0) 
    red = red_p | red_k
    l_red_k, l_red_p = [],[]

    # BLUE
    # blue pawn move bitboards
    blue_p_forward = np.uint64(0b0000000001111110111111111111111111111111111111111111111111111111)
    blue_p_right = np.uint64(0b0000000011111110111111101111111011111110111111101111111011111100)
    blue_p_left = np.uint64(0b0000000001111111011111110111111101111111011111110111111100111111)

    # blue pawn hit bitboards
    blue_p_hit_right = np.uint64(0b0000000011111100111111101111111011111110111111101111111011111110)
    blue_p_hit_left = np.uint64(0b0000000000111111011111110111111101111111011111110111111101111111)

    # blue knights move/hit bitboards
    blue_k_forward_right = np.uint64(0b0000000000000000111111001111111011111110111111101111111011111110)
    blue_k_right = np.uint64(0b0000000011111000111111001111110011111100111111001111110011111100)
    blue_k_forward_left = np.uint64(0b0000000000000000001111110111111101111111011111110111111101111111)
    blue_k_left = np.uint64(0b0000000000011111001111110011111100111111001111110011111100111111)

    # Shifts for moves
    # Pawns
    # Forward, left, right, hit left, hit right
    bpf, bpl, bpr, bphl, bphr = np.uint8(8), np.uint8(1), np.uint8(1), np.uint8(9), np.uint8(7)

    #Knights
    # left, forward left, right, forward right
    bkl, bkfl, bkr, bkfr = np.uint8(10), np.uint8(17), np.uint8(6), np.uint8(15)

    # RED
    # red pawn move bitboards
    red_p_forward = np.uint64(0b1111111111111111111111111111111111111111111111110111111000000000)
    red_p_left = np.uint64(0b0011111101111111011111110111111101111111011111110111111100000000)
    red_p_right = np.uint64(0b1111110011111110111111101111111011111110111111101111111000000000)

    # red pawn hit bitboards
    red_p_hit_right = np.uint64(0b1111111111111110111111101111111011111110111111101111110000000000)
    red_p_hit_left = np.uint64(0b1111111101111111011111110111111101111111011111110011111100000000)

    # red knights move/hit bitboards
    red_k_forward_right = np.uint64(0b1111111011111110111111101111111011111110111111000000000000000000)
    red_k_right = np.uint64(0b1111110011111100111111001111110011111100111111001111100000000000)
    red_k_forward_left = np.uint64(0b0111111101111111011111110111111101111111001111110000000000000000)
    red_k_left = np.uint64(0b0011111100111111001111110011111100111111001111110001111100000000)

    # Shifts for moves
    # Pawns
    # Forward, left, right, hit left, hit right
    rpf, rpl, rpr, rphl, rphr = np.uint8(8), np.uint8(1), np.uint8(1), np.uint8(7), np.uint8(9)

    #Knights
    # left, forward left, right, forward right
    rkl, rkfl, rkr, rkfr = np.uint8(6), np.uint8(15), np.uint8(10), np.uint8(17)

    @staticmethod
    def blue_p_move_generation(source:np.uint64) -> list:  
        dests = []
        blocked_squares = ~(Board.red | Board.blue_k) # Pawns unmovable squares
        # forward
        if (source & Board.blue_p_forward) << Board.bpf & blocked_squares: dests.append(source << Board.bpf) 
        # left
        if (source & Board.blue_p_left) << Board.bpl & blocked_squares: dests.append(source << Board.bpl) 
        # hit left
        if (source & Board.blue_p_hit_left) << Board.bphl & Board.red: dests.append(source << Board.bphl) 
        # hit right
        if (source & Board.blue_p_hit_right) << Board.bphr & Board.red: dests.append(source << Board.bphr) 
        # right
        if (source & Board.blue_p_right) >> Board.bpr & blocked_squares: dests.append(source >> Board.bpr) 
        return dests

    @staticmethod
    def blue_k_move_generation(source:np.uint64) -> list: 
        dests = []
        # left
        if (source & Board.blue_k_left) << Board.bkl & ~Board.blue_k: dests.append(source << Board.bkl) 
        # forward_left
        if (source & Board.blue_k_forward_left) << Board.bkfl & ~Board.blue_k: dests.append(source << Board.bkfl) 
        # right
        if (source & Board.blue_k_right) << Board.bkr & ~Board.blue_k: dests.append(source << Board.bkr) 
        # forward_right
        if (source & Board.blue_k_forward_right) << Board.bkfr & ~Board.blue_k: dests.append(source << Board.bkfr) 
        return dests

    @staticmethod
    def blue_p_move_execution(source:np.uint64, dest:np.uint64) -> None:
        # delete source Position 
        Board.l_blue_p.remove(source)
        Board.blue_p = Board.blue_p ^ source

        # on red_k -> hit & knight
        if dest & Board.red_k:
            # remove red knight
            
            Board.red_k = Board.red_k ^ dest
            Board.l_red_k.remove(dest)

            # add blue knigth
            Board.blue_k = Board.blue_k | dest
            Board.l_blue_k.append(dest)

            # new red
            Board.red = Board.red_p | Board.red_k
            Board.stack.append((source, dest, True))

        # on blue_p -> knight
        elif dest & Board.blue_p:
            # add blue knight
            Board.blue_k = Board.blue_k | dest
            Board.l_blue_k.append(dest)
            Board.stack.append((source, dest))


        # on red_p -> hit
        elif dest & Board.red_p:
            # remove red pawn
            Board.red_p = Board.red_p ^ dest
            Board.l_red_p.remove(dest)

            # move blue pawn
            Board.blue_p = Board.blue_p | dest
            Board.l_blue_p.append(dest)
            
            # new red
            Board.red = Board.red_p | Board.red_k
            Board.stack.append((source, dest, True))

        # simple move
        else: 
            # move blue pawn
            Board.blue_p = Board.blue_p | dest
            Board.l_blue_p.append(dest)
            Board.stack.append((source, dest))
        
        # new blue
        Board.blue = Board.blue_p | Board.blue_k
    
    @staticmethod
    def blue_k_move_execution(source:np.uint64, dest:np.uint64) -> None:
        # delete source Position 
        Board.blue_k = Board.blue_k ^ source
        Board.l_blue_k.remove(source)

        
        
        # on red_k -> hit & knight
        if dest & Board.red_k:
            # remove red knight
            Board.red_k = Board.red_k ^ dest
            Board.l_red_k.remove(dest)

            # add blue knight
            Board.blue_k = Board.blue_k | dest
            Board.l_blue_k.append(dest)

            # new red
            Board.red = Board.red_p | Board.red_k
            Board.stack.append((source, dest, True))

        # on blue_p -> knight
        elif dest & Board.blue_p:
            # add blue knight
            Board.blue_k = Board.blue_k ^ dest
            Board.l_blue_k.append(dest)
            Board.stack.append((source, dest))

        # on red_p -> hit & pawn
        elif dest & Board.red_p:
            # remove red pawn
            Board.red_p = Board.red_p ^ dest
            Board.l_red_p.remove(dest)
            
            # add blue pawn
            Board.blue_p = Board.blue_p | dest
            Board.l_blue_p.append(dest)
            
            # new red
            Board.red = Board.red_p | Board.red_k
            Board.stack.append((source, dest, True))


        # simple move -> pawn
        else: 
            # add blue pawn
            Board.blue_p = Board.blue_p | dest
            Board.l_blue_p.append(dest)
            Board.stack.append((source, dest))
        
        # new blue
        Board.blue = Board.blue_p | Board.blue_k
    
    @staticmethod
    def blue_generation():
        moves = []
        precon = ~(Board.blue_k | Board.red_k)
        for source in Board.l_blue_p:	
            if source & precon:   #pre-validation (pawn under knight)
                fig_moves = Board.blue_p_move_generation(source)
                if len(fig_moves):
                    moves.append((source, fig_moves))
        for source in Board.l_blue_k:
            fig_moves = Board.blue_k_move_generation(source)
            if len(fig_moves):
                moves.append((source, fig_moves))
        return moves

    @staticmethod
    def blue_takeback(source, dest, hit=False):
        # hit (add red)
        if hit:
            if Board.blue_k & dest:
                Board.l_red_k.append(dest)
                Board.red_k = Board.red_k | dest
            else:
                Board.l_red_p.append(dest)
                Board.red_p = Board.red_p | dest
            Board.red = Board.red_p | Board.red_k

        # delete dest
        if Board.blue_k & dest:
            del Board.l_blue_k[-1]
            Board.blue_k = Board.blue_k ^ dest
        else:
            del Board.l_blue_p[-1]
            Board.blue_p = Board.blue_p ^ dest

        # add source
        if (Board.blue_p | Board.red_p) & source:
            Board.l_blue_k.append(source)
            Board.blue_k = Board.blue_k | source
        else:
            Board.l_blue_p.append(source)
            Board.blue_p = Board.blue_p | source
        
        Board.blue = Board.blue_p | Board.blue_k

    ############ Red ##################

    @staticmethod
    def red_p_move_generation(source:np.uint64) -> list:	# after pre-validation wheather source can move (being below knight
        dests = []
        # Pawns unmovable squares
        blocked_squares = ~(Board.blue | Board.red_k)

        # forward
        if (source & Board.red_p_forward) >> Board.rpf & blocked_squares:
            dests.append(source >> Board.rpf) 

        # left
        if (source & Board.red_p_left) << Board.rpl & blocked_squares:
            dests.append(source << Board.rpl) 

        # right
        if (source & Board.red_p_right) >> Board.rpr & blocked_squares:
            dests.append(source >> Board.rpr) 

        # hit left
        if (source & Board.red_p_hit_left) >> Board.rphl & Board.blue:
            dests.append(source >> Board.rphl) 

        # hit right
        if (source & Board.blue_p_hit_right) >> Board.rphr & Board.blue:
            dests.append(source >> Board.rphr) 
        
        return dests

    @staticmethod
    def red_k_move_generation(source:np.uint64) -> list: # no pre-validation needed
        dests = []
        # left
        if (source & Board.red_k_left) >> Board.rkl & ~Board.red_k:
            dests.append(source >> Board.rkl) 

        # forward_left
        if (source & Board.red_k_forward_left) >> Board.rkfl & ~Board.red_k:
            dests.append(source >> Board.rkfl) 

        # right
        if (source & Board.red_k_right) >> Board.rkr & ~Board.red_k:
            dests.append(source >> Board.rkr) 

        # forward_left
        if (source & Board.red_k_forward_right) >> Board.rkfr & ~Board.red_k:
            dests.append(source >> Board.rkfr) 

        return dests

    @staticmethod
    def red_p_move_execution(source:np.uint64, dest:np.uint64) -> None:
        # delete source Position 
        Board.l_red_p.remove(source)
        Board.red_p = Board.red_p ^ source

        # on blue_k -> hit & knight
        if dest & Board.blue_k:
            # remove blue knight
            Board.blue_k = Board.blue_k ^ dest
            Board.l_blue_k.remove(dest)

            # add red knight
            Board.red_k = Board.red_k | dest
            Board.l_red_k.append(dest)
            
            # new blue
            Board.blue = Board.blue_p | Board.blue_k
            Board.stack.append((source, dest, True))
            
        # on red_p -> knight
        elif dest & Board.red_p:
            # add blue knight
            Board.red_k = Board.red_k | dest
            Board.l_red_k.append(dest)
            Board.stack.append((source, dest))

        # on blue_p -> hit
        elif dest & Board.blue_p:
            # remove blue pawn
            Board.blue_p = Board.blue_p ^ dest
            Board.l_blue_p.remove(dest)

            # move red pawn 
            Board.red_p = Board.red_p | dest
            Board.l_red_p.append(dest)

            # new blue
            Board.blue = Board.blue_p | Board.blue_k
            Board.stack.append((source, dest, True))

        # simple move
        else: 
            Board.red_p = Board.red_p | dest
            Board.l_red_p.append(dest)
            Board.stack.append((source, dest))
        
        # new red
        Board.red = Board.red_p | Board.red_k

    @staticmethod
    def red_k_move_execution(source:np.uint64, dest:np.uint64) -> None:
        # delete source Position 
        Board.red_k = Board.red_k ^ source
        Board.l_red_k.remove(source)
        
        # on blue_k -> hit & knight
        if dest & Board.blue_k:
            # remove blue knight
            Board.blue_k = Board.blue_k ^ dest
            Board.l_blue_k.remove(dest)

            # add red knight
            Board.red_k = Board.red_k | dest
            Board.l_red_k.append(dest)

            # new blue
            Board.blue = Board.blue_p | Board.blue_k
            Board.stack.append((source, dest, True))

        # on red_p -> knight
        elif dest & Board.red_p:
            # add red knight
            Board.red_k = Board.red_k ^ dest
            Board.l_red_k.append(dest)
            Board.stack.append((source, dest))

        # on blue_p -> hit & pawn
        elif dest & Board.blue_p:
            # remove blue pawn
            Board.blue_p = Board.blue_p ^ dest
            Board.l_blue_p.remove(dest)
            
            # add red pawn
            Board.red_p = Board.red_p | dest
            Board.l_red_p.append(dest)
            
            # new blue
            Board.blue = Board.blue_p | Board.blue_k
            Board.stack.append((source, dest, True))

        # simple move -> pawn
        else: 
            # add red pawn
            Board.red_p = Board.red_p | dest
            Board.l_red_p.append(dest)
            Board.stack.append((source, dest))

        # new red
        Board.red = Board.red_p | Board.red_k

    @staticmethod
    def red_generation() -> list:
        moves = []
        precon = ~(Board.blue_k | Board.red_k)
        for source in Board.l_red_p:	
            if source & precon:   #pre-validation (pawn under knight)
                fig_moves = Board.red_p_move_generation(source)
                if len(fig_moves):
                    moves.append((source, fig_moves))
        
        for source in Board.l_red_k:
            fig_moves = Board.red_k_move_generation(source)
            if len(fig_moves):
                moves.append((source, fig_moves))
        return moves

    @staticmethod        
    def red_takeback(source, dest, hit=False) -> None:
        # hit (add blue)
        if hit:
            if Board.red_k & dest:
                Board.l_blue_k.append(dest)
                Board.blue_k = Board.blue_k | dest
            else:
                Board.l_blue_p.append(dest)
                Board.blue_p = Board.blue_p | dest
            Board.blue = Board.blue_p | Board.blue_k

        # delete dest
        if Board.red_k & dest:
            del Board.l_red_k[-1]
            Board.red_k = Board.red_k ^ dest
        else:
            del Board.l_red_p[-1]
            Board.red_p = Board.red_p ^ dest

        # add source
        if (Board.blue_p | Board.red_p) & source:
            Board.l_red_k.append(source)
            Board.red_k = Board.red_k | source
        else:
            Board.l_red_p.append(source)
            Board.red_p = Board.red_p | source

        Board.red = Board.red_p | Board.red_k


    @staticmethod
    def eval() -> int:
        """
        Returns: evaluation of the current board
        """
        # Hits
        # Blue hits
        blue_k_hits = (Board.blue_k & Board.blue_k_forward_left << Board.bkfl) | (Board.blue_k & Board.blue_k_forward_right << Board.bkfr) | (Board.blue_k & Board.blue_k_left << Board.bkl) | (Board.blue_k & Board.blue_k_right << Board.bkr) if Board.blue_k else np.uint64(0)
        blue_p_hits = (Board.blue_p & Board.blue_p_hit_left << Board.bphl) | (Board.blue_p & Board.blue_p_hit_right << Board.bphr)

        # Red hits
        red_k_hits = (Board.red_k & Board.red_k_forward_left >> Board.rkfl) | (Board.red_k & Board.red_k_forward_right >> Board.rkfr) | (Board.red_k & Board.red_k_left >> Board.rkl) | (Board.red_k & Board.red_k_right >> Board.rkr) if Board.red_k else np.uint64(0)
        red_p_hits = (Board.red_p & Board.red_p_hit_left >> Board.rphl) | (Board.red_p & Board.red_p_hit_right >> Board.rphr)

        # Potential Knights
        # Blue knights
        blue_pot_k = Board.blue_p & ((Board.blue_p & Board.blue_p_forward << Board.bpf) | (Board.blue_p & Board.blue_p_left << Board.bpl) | (Board.blue_p & Board.blue_p_right >> Board.bpr) | (blue_p_hits & Board.red_k))

        # Red knights
        red_pot_k = Board.red_p & ((Board.red_p & Board.red_p_forward >> Board.rpf) | (Board.red_p & Board.red_p_left << Board.rpl) | (Board.red_p & Board.red_p_right >> Board.rpr) | (red_p_hits & Board.blue_k))
        return 0

    ############################ TESTING ############################
    @staticmethod
    def state(message="") -> None:
        def board_to_string(board:np.uint64)->str:
            return np.binary_repr(board,width=64)
        def print_board(board:np.uint64):
            string = np.binary_repr(board,width=64)
            #str = 'X' + str[1:7]+'X'+str[8:56]+'X'+str[57:63]+'X'
            print('\n'.join(string[i:i+8] for i in range(0, len(string), 8)))
            print()
        if message:
            print(f"------------- {message}  --------------------------")
        else:
            print("-----------------------------------------------------");print()
	
        red_p,blue_p ,red_k ,blue_k = np.uint64(0),np.uint64(0),np.uint64(0),np.uint64(0)
        for p in Board.l_blue_p: blue_p = blue_p ^ p
        for k in Board.l_blue_k: blue_k = blue_k ^ k
        for p in Board.l_red_p: red_p = red_p ^ p
        for k in Board.l_red_k: red_k = red_k ^ k

        if blue_p==Board.blue_p:
            if blue_k==Board.blue_k:
                if blue_p | blue_k!=Board.blue:
                    print("blue")
                    print_board(blue_p | blue_k)
                    print("board.blue")
                    print_board(Board.blue)
                    raise Exception("blue != board.blue")

            else:
                print("blue_k")
                print_board(Board.blue_k)
                print("l_blue_k")
                print_board(blue_k)
                raise Exception("blues knights != l_blues_knights")
        else:
            print("blue_p")
            print_board(Board.blue_p)
            print("l_blue_p")
            print_board(blue_p)
            raise Exception("blues pawns != l_blues_pawns")

        if red_p==Board.red_p: 
            if red_k==Board.red_k:
                if red_p | red_k!=Board.red:
                    print("red")
                    print_board(red_p | red_k)
                    print("board.red")
                    print_board(Board.red)
                    raise Exception("red != board.red")		
            else:
                print("red_k")
                print_board(Board.red_k)
                print("l_red_k")
                print_board(red_k)
                raise Exception("red knights != l_red_knights")
        else:
            print("red_p")
            print_board(Board.red_p)
            print("l_red_p")
            print_board(red_p)
            raise Exception("red pawns != l_red_pawns")
        
        s=""
        BLUE = "\033[34m"
        RED = "\033[31m"
        RESET = "\033[0m"

        for rp,bp,rk,bk in zip(board_to_string(red_p).replace('1','r'),board_to_string(blue_p ).replace('1','b'),board_to_string(red_k ).replace('1','R'),board_to_string(blue_k).replace('1','B')):
            if rk!="0":
                s+="R"
            elif bk!="0":
                s+="B"
            elif rp!="0":
                s+="r"
            elif bp!="0":
                s+="b"
            else:
                s+="0"
        s='\n'.join(s[i:i+8] for i in range(0, len(s), 8))
        print(s.replace("R",RED+"K"+RESET).replace("B",BLUE+"K"+RESET).replace("r",RED+"P"+RESET).replace("b",BLUE+"P"+RESET))
        # print_board(blue_p)
        # print_board(blue_k)
        # print_board(red_p)
        # print_board(red_k)
        print(f"Blue Turn?: {Board.blue_turn}")
        print(f"Stack: {Board.stack}")

    @staticmethod
    def play(FEN_board=False, blue_turn=True):
        if FEN_board:
            Board.initBoard(*GameState.createBitBoardFrom(Gui.fenToMatrix(FEN_board),True),blue_turn)
        else:
            Board.initBoard(np.uint64(0b0111111001111110000000000000000000000000000000000000000000000000), np.uint64(0),np.uint64(0b0111111001111110), np.uint64(0),blue_turn)
        Board.state("Startpos")

        def rand_move_execution(moves):
            fig = random.choice(moves)
            move = random.choice(fig[1])
            Board.exec_move(fig[0],move)
            return fig[0],move

        while Board.isOver() == "":
            moves = Board.generate_moves()
            print(f"moves: {moves}")

            rand_move_execution(moves)

            Board.state()
            inp = input("Takeback? -> Enter 't': ")
            
            if inp =="t":
                Board.takeback()
                Board.state("Takeback")
            
        print(Board.isOver())

if __name__ == "__main__":
    # simple figure
    #test = "6/b07/8/8/8/8/8/6 b"

	# Blue Pawns
    # test = "1b04/8/8/8/8/8/8/6 b"
    # test = "8/r0b0r05/8/8/8/8/8/6 b"
    # test = "6/8/8/8/8/b0r06/8/6 b"
    # test = "6/8/8/8/8/6r0b0/8/6 b"
    # test = "6/8/8/8/8/7b0/7r0/6 b"
	# test = "6/8/8/8/8/8/7b0/6 b"
    # test = "8/rr0b0rr05/8/8/8/8/8/6 b"
    # test = "8/br0b0br05/8/8/8/8/8/6 b"
    
    # test = "6/8/8/8/8/8/6b0b0/6 b"

	# blue hits
	# hit pawn
    # test = "6/8/8/8/8/r0b0r05/r0r0r05/6 b"
	# hit double red knight
    # test = "6/8/8/8/8/rr0b0rr05/rr0rr0rr05/6 b"
	# hit red blue knight
    # test = "6/8/8/8/8/rr0b0rr05/br0rr0br05/6 b"

	# Blue knights
    # test = "6/2bb05/8/8/8/8/8/6 b"
    # test = "6/2bb05/rr07/1r01b0/8/8/8/6 b"

	# on r pawn?
	# test = "6/bb07/8/1r06/8/8/8/6 b"

	# on b pawn?
	#test = "6/bb07/8/1b06/8/8/8/6 b"

	# on rr knigth?
	# test = "6/bb07/8/1rr06/8/8/8/6 b"

	# on br knight?
    # test = "6/bb07/8/1br06/8/8/8/6 b"

	# on bb knigth?
    # test = "6/bb07/8/1bb06/8/8/8/6 b"

	############################################
	# Red Pawns
	# test = "8/8/8/8/8/8/b0r0b05/6 r"
	# test = "6/7b0/7r0/8/8/8/8/6 r"
	# test = "6/7r0/8/8/8/8/8/6 r"
	# test = "8/rb0r0rb05/8/8/8/8/8/6 r"
	# test = "8/bb0r0bb05/8/8/8/8/8/6 r"

	# test = "6/6r0r0/8/8/8/8/8/6 r"

	# Red hits
	# hit pawn
    # test = "6/b0b0b05/b0r0b05/8/8/8/8/6 r"
	# hit double red knight
    # test = "6/bb0bb0bb05/bb0r0bb05/8/8/8/8/6 r"
	# hit red blue knight
    # test = "6/rb0rb0bb05/rb0r0rb05/8/8/8/8/6 r"


	# Red knights
    # test = "6/8/8/8/8/8/2rr05/6 r"

	# on b pawn?
    # test = "6/8/8/8/1b06/8/rr07/6 r"

	# on r pawn?
    # test = "6/8/8/8/1r06/8/rr07/6 r"

	# on bb knigth
    # test = "6/8/8/8/1bb06/8/rr07/6 r"

	# on rb knight?
    # test = "6/8/8/8/1rb06/8/rr07/6 r"

	# on rr knigth?
    test = "6/8/8/8/1rr06/8/rr07/6 r"

    b, player = test.split(" ")
    game = {"board": b,
			"player": player,
			"player1": True,
			"player2": False,
	}
    # For Blue
    # Board.play(game["board"])

    # For Red
    Board.play(game["board"],False)
    